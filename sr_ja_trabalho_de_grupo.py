# -*- coding: utf-8 -*-
"""SR_JA_trabalho_de_grupo (Parte I - Python).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bztTR1_ieUgI-h6wVfD8lX5J-igNig22

# PGDS Rumos - Programa√ß√£o em Python 
### Trabalho pr√°tico de grupo (Parte I)

Data limite de entrega: 24 de Fevereiro de 2020 √†s 23:59

---

O trabalho consiste em 7 exerc√≠cios de programa√ß√£o, **dos quais t√™m de resolver 6**, onde ter√£o a oportunidade de aplicar os conceitos de Python aprendidos nas primeiras 3 aulas.

# **Trabalho Realizado por Sofia Ribeiro e Jo√£o Ascens√£o**

## Exerc√≠cio 1

Escreva uma fun√ß√£o `get_words` que devolva o _conjunto_ de palavras que ocorrem numa string em L√≠ngua Portuguesa, em min√∫sculas. N√£o se esque√ßa de retirar a pontua√ß√£o!

**Exemplo:**

Para `s = "Atirei o pau ao gato, mas o gato n√£o morreu; Dona Chica assustou-se com o berro que o gato deu.`

temos que
`get_words(s) == {'atirei', 'o', 'pau', 'ao', 'gato', 'mas', 'n√£o', 'morreu',
'dona', 'chica', 'assustou-se', 'com', 'berro', 'que', 'deu'}`
"""

def get_words(s):

  #Verifica a exist√™ncia de pontua√ß√£o concatenando uma string com os caracteres que n√£o se encontrem nessa lista, 
  #ao retornar o valor converte-se para set de modo a obtermos o resultado pretendido

  pontuacao = '''!()[]{};:'"\,<>./?@#$%^&*_~'''
  resultado = ""

  for c in s:
    if c not in pontuacao:
        resultado = resultado + c
        
  return set( resultado.split() )

# testes:

get_words('Atirei o pau ao gato, mas o gato n√£o morreu; Dona Chica assustou-se com o berro que o gato deu.')

"""## Exerc√≠cio 2

Escreva uma fun√ß√£o `has_repeated` que, dada uma string `s`, devolva `True` se `s` contiver caracteres repetidos e `False` caso contr√°rio.
"""

def f(s):

  #Fazemos a verifica√ß√£o do tamanho da string com o tamanho da string convertida em set onde vai colocar apenas os valores √∫nicos.
  
  if len( set(s) ) == len(s):
    return False
  else:
    return True
    
# testes: esta c√©lula n√£o deve dar erros AssertionError!

assert f('abc') == False
assert f('aba') == True
assert f('  a') == True
assert f('carlos') == False
assert f('Aa') == False

"""## Exerc√≠cio 3

Escreva uma fun√ß√£o `barchart` que, dada uma lista ou tuplo de inteiros, produza (`print`) um ``gr√°fico de barras`` com os valores da lista ou tuplo como ilustrado abaixo:

**Nota:** N√£o √© necess√°rio validar que se tratam efectivamente de inteiros.

**Exemplo:**
A lista ``l = [3, 4, 20, 15, 3, 4]`` deve produzir `f(l)`

```
|***| 3
|****| 4
|********************| 20
|***************| 15
|***| 3
|****| 4
```
"""

def bar_chart(l):

  #Fazemos a valida√ß√£o se a lista ou tuplo s√£o inteiros imprimindo at√© o tipo que est√° a ser tratado

  if all( isinstance(x, int) for x in l ):
     temp=''

     if type(l) is tuple:
       print ('Tuple')
     else:
       print ('List')

     for p in l:
       print ('|' + '*'*p + '| ' + str(p) + '\n')

  else:
    print('S√≥ aceita inteiros')

# testes:

li=[3, 4, 20, 15, 3, 4]
bar_chart(li)

"""## Exerc√≠cio 4

Escreva uma fun√ß√£o `median` em Python puro (sem recurso a bibliotecas importadas via `import`!) que encontre a mediana de uma lista de n√∫meros `float`.

**Nota:** Para efeitos deste exerc√≠cio, considere que a lista tem um n√∫mero √≠mpar de elementos!
"""

def median(l):

  #Validamos se a lista √© uma lista de floats, ap√≥s isso obtemos o tamanho da lista e ordenamos a mesma 
  #analisamos a lista se a mesma for par o valor da mediana vai ser a soma dos valores centrais a dividir a dividir por 2,
  # caso seja impar vai ser o valor central que se encontra na lista

  if all( isinstance(x, float) for x in l ):
    n = len(l) 
    l.sort() 

    if n % 2 == 0: 
        median = (l[n//2] + l[n//2 - 1] )/2
    else: 
        median = l[n//2] 

    print("O Valor da mediana √©: " + str(median))

  else:
    print('S√≥ aceita listas do tipo float') 

# testes:

me=[25.0 ,4.7 ,5.1, 7.1 ,9.9]
median(me)

"""## Exerc√≠cio 5

Escreva uma fun√ß√£o `mode` em Python puro (sem recurso a bibliotecas importadas via `import`, excepto possivelmente a biblioteca `collections`!) que encontre a moda estat√≠stica de uma lista de n√∫meros `int`.
"""

import collections
def mode(l):

  #Validamos se a lista √© de inteiros, usamos a fun√ß√£o counter para contar o n√∫mero de vezes que cada elemento se encontra na lista,
  #convertemos para dicion√°rio e no dicion√°rio vamos comparar cada elemento com o maior valor do contador , o elemento que corresponder √© a moda, 
  #caso todos os valores sejam unicos n√£o temos moda

  if all( isinstance(x, int) for x in l ):

    contador = collections.Counter(l) 
    dictcont = dict(contador) 
    moda = [number for number, value in dictcont.items() if value == max(list(contador.values())) ] 

    if len(moda) == len(l): 
        print('N√£o existe moda')
    else: 
        print( "O valor da moda √© " + ', '.join( map(str, moda) ) ) 
        
  else:
    print ('S√≥ aceita listas de inteiros')

# testes:

mo=[1,2,3,4,5,5]
mode(mo)

"""## Exerc√≠cio 6

Escreva uma fun√ß√£o `is_email` que retorne `True` se uma string for um endere√ßo de e-mail e `False` caso contr√°rio.

**Nota:** Para efeitos deste exerc√≠cio, considere que um endere√ßo de e-mail:

- cont√©m exactamente uma `arroba` (@);
- cont√©m apenas letras min√∫sculas antes da arroba;
- cont√©m apenas um ponto, e este est√° a seguir √† arroba;
- cont√©m apenas letras min√∫sculas antes do ponto, e apenas letras a seguir ao ponto.
- n√£o cont√©m caracteres al√©m de letras min√∫sculas, pontos e arrobas.

**Exemplos:**

- `is_email("luismbpsousa@gmail.com")` deve retornar `True`,
 mas
- `is_email("joao.Ratao33 at carochinha.pt")` deve retornar `False`

**Complemento:** 
N√£o √© necess√°rio escrever manualmente uma lista com todos os caracteres do alfabeto. Pode usar a seguinte lista:

`letras_minusculas = [chr(x) for x in range(ord('a'), ord('z') + 1)]`
"""

def is_email(s):

  #valida presen√ßa de @ tem que ser exatamente 1

  if s.count('@')!=1:
    return False

  #verifica posi√ß√£o ponto e apenas pode conter 1

  if s.count('.')>1 and s.index('.')<s.index('@'):
   return False
  
  #verifica minusculas retirando o '@' e o '.' da string dado j√° terem sido validados anteriormente, usei a lista minusculas para retirar √£ por exemplo
  letras_minusculas = [chr(x) for x in range(ord('a'), ord('z') + 1)]
  nminusculas=all(list(map(lambda x:x.islower() and x in letras_minusculas,s.replace('@','').replace('.',''))))

  return nminusculas

assert is_email('jo√£o@gmail.com') == False
assert is_email('luismbpsousa@gmail.com') == True
assert is_email('joao.Ratao33 at carochinha.pt') == False

"""# Exerc√≠cio 7

Verifique a [Lei de Benford](https://pt.wikipedia.org/wiki/Lei_de_Benford) para a popula√ß√£o residente em cidades em Portugal.

Em detalhe: usando o dicion√°rio `data` abaixo, contendo as popula√ß√µes residentes nas cidades portuguesesas, verifique se a distribui√ß√£o do primeiro d√≠gito dessas popula√ß√µes segue aproximadamente ou n√£o a Lei de Benford (cuja distribui√ß√£o se encontra j√° calculada em `benford_freqs`). 
Comece por transformar cada popula√ß√£o no seu primeiro d√≠gito, depois extraia a sua distribui√ß√£o de frequ√™ncias absolutas, e por fim as relativas.

**N√£o √© necess√°rio realizar testes estat√≠sticos (como o Kolmogorov-Smirnov), apenas uma compara√ß√£o informal.**

**Nota:** Deve retirar da sua an√°lise os valores iguais a zero.
"""

# Se este link falhar, podem obter um novo para o mesmo dataset em https://dados.gov.pt/pt/datasets/populacao-residente-em-cidades-n-o/ 
# Em Dataset json url, clicar em Copiar permalink para a √°rea de transfer√™ncia e col√°-lo em baixo üëáüèΩ

url = "https://dados.gov.pt/pt/datasets/r/1b8ee646-144d-4532-985d-3d62a058653e"

import json
import requests
import math
from collections import Counter

benford_freqs = {d: math.log10(1 + 1/d) for d in range(1, 10)}

r = json.loads(requests.get(url).text)
data = {x['geodsg']: int(x['valor']) for x in r[0]['Dados']['2013'] if len(x['geocod']) == 7}

#Cria dicion√°rio com numera√ß√£o n√∫merica 1 a 9
dictfr={
  "1":{"fa" : 0,
       "fr" :0
       },
  "2": {"fa" : 0,
       "fr" :0
       },
  "3":{"fa" : 0,
       "fr" :0
       },
  "4": {"fa" : 0,
       "fr" :0
       },
  "5": {"fa" : 0,
       "fr" :0
       },
  "6": {"fa" : 0,
       "fr" :0
       },
  "7": {"fa" : 0,
       "fr" :0
       },
  "8": {"fa" : 0,
       "fr" :0
       },
  "9": {"fa" : 0,
       "fr" :0
       },
}

#Filtra os dados do dicion√°rio retirando os 0.

newdata = dict(filter(lambda x: x[1] > 0, data.items()))

#Vamos obter o valor total de registos v√°lidos

totalamostra=len(newdata.keys())
for cidade,valor in newdata.items():

  #Obtemos o primeiro digito do n√∫mero de popula√ß√µes
  firstnumber=str(valor)[:1]
  
  #obtemos o valor que se encontra no dicion√°rio incrementando para cada n√∫mero encontrado.
  valuefa=dictfr[firstnumber]['fa']
  valuefa+=1
  dictfr[firstnumber]['fa']=valuefa
  dictfr[firstnumber]['fr']=valuefa/totalamostra

#verificamos a diferen√ßa entre eles
dictdif={}
for x in benford_freqs.items():
  tempfa=dictfr[str(x[0])]['fr']
  dictdif[str(x[0])]=x[1]-tempfa

dictdif

"""# Divirtam-se! :)

Lu√≠s Miguel Sousa
"""